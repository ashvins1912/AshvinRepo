contractCodeList = contractCodeList.stream()
    .filter(obj -> !obj.getId().equals(contractCode.getId()))
    .collect(Collectors.toList());

contractCodeList.add(contractCode);

// Sort list by effective date
contractCodeList.sort(Comparator.comparing(ContractCode::getContractEffDate));

List<ContractCode> result = new ArrayList<>();
result.add(contractCodeList.get(0));

for (int i = 1; i < contractCodeList.size(); i++) {
    ContractCode prev = result.get(result.size() - 1);
    ContractCode current = contractCodeList.get(i);

    // 1. Basic check: EffDate must not be after TermDate
    if (current.getContractEffDate().isAfter(current.getContractTermDate())) {
        throw new IntegrationInvalidException("ContractEffDate cannot be after ContractTermDate.");
    }

    // 2. Duplicate effective date check
    if (current.getContractEffDate().equals(prev.getContractEffDate())) {
        throw new IntegrationInvalidException("Duplicate ContractEffDate found: " + current.getContractEffDate());
    }

    // 3. Check for overlap
    if (!current.getContractEffDate().isAfter(prev.getContractTermDate())) {
        // Adjust previous term date to 1 day before current eff date
        LocalDate adjustedTermDate = current.getContractEffDate().minusDays(1);
        if (!adjustedTermDate.isBefore(prev.getContractEffDate())) {
            prev.setContractTermDate(adjustedTermDate);
        } else {
            throw new IntegrationInvalidException("Contract date overlap cannot be resolved between: " +
                    prev.getContractEffDate() + " - " + prev.getContractTermDate() + " and " +
                    current.getContractEffDate() + " - " + current.getContractTermDate());
        }
    }

    result.add(current);
}